#!/usr/bin/env python3
#
# Author: Louwrentius
#
# Requirement: hdparm, ethtool, smartmontools
#

import re
import subprocess
import sys
import os
import argparse
import json

def set_arguments():
    parser = argparse.ArgumentParser(description='Show detailed disk|net device information in ASCII table format')
    parser.add_argument('devicetype',  choices=['disk', 'net'], help="Show disk information")

    sa = parser.add_argument_group(title="Generic settings", description="Options that apply for all device types.")
    sa.add_argument("-E",  "--transparent", action="store_true", help="Disable table formatting (no lines)")
    sa.add_argument("-g",  "--noheader", action="store_true",  help="Disable table header (in transparent mode)")

    sg = parser.add_argument_group(title="Storage (generic)", description="Generic options for storage devices")
    sg.add_argument("-a",  "--all-opts", action="store_true",  help="show all information")
    sg.add_argument("-m",  "--model",action="store_true", help="device model")
    sg.add_argument("-k",  "--type",action="store_true", help="device type (HDD/SDD)")
    sg.add_argument("-S",  "--serial",action="store_true", help="device serial number")
    sg.add_argument("-D",  "--state", action="store_true", help="drive power status (active/standby)")
    sg.add_argument("-e",  "--apm", action="store_true", help="Advanced Power Mode")
    sg.add_argument("-s",  "--size", action="store_true", help="device size in Gigabytes")
    sg.add_argument("-z",  "--speed", action="store_true", help="SATA Link in Gbps")
    sg.add_argument("-f",  "--firmware", action="store_true", help="device firmware version")
    sg.add_argument("-c",  "--controller",  action="store_true", help="controller to which device is connected")
    sg.add_argument("-p",  "--pcipath",  action="store_true", help="/dev/disk/by-path/ ID of the device")
    sg.add_argument("-w",  "--wwn",  action="store_true", help="device World Wide Name")
    sg.add_argument("-o",  "--scsi",  action="store_true", help="/dev/by-id/scsi")

    ss = parser.add_argument_group(title="Storage (SMART)",  description="Options based on SMART values of storage devices")
    ss.add_argument("-t",  "--temp",  action="store_true",  help="temperature in Celcius")
    ss.add_argument("-H",  "--hours",  action="store_true",  help="power on hours")
    ss.add_argument("-P",  "--pending",  action="store_true",  help="pending sector count")
    ss.add_argument("-r",  "--reallocated",  action="store_true",  help="reallocated sector count")
    ss.add_argument("-R",  "--reallocatedevent",  action="store_true",  help="reallocated sector event count")
    ss.add_argument("-C",  "--crc",  action="store_true",  help="CRC error")
    ss.add_argument("-u",  "--startstop",  action="store_true",  help="spin up/down")
    ss.add_argument("-n",  "--park",  action="store_true",  help="head parking")

    nw = parser.add_argument_group(title="Network", description="Available options for `network devices")
    nw.add_argument("-l",  "--link",  action="store_true", help="network card link status")
    nw.add_argument("-4",  "--ipv4",  action="store_true", help="IPv4 address")
    nw.add_argument("-6",  "--ipv6",  action="store_true", help="IPv6 address")
    nw.add_argument("-M",  "--mac",  action="store_true", help="hardware / MAC address")
    nw.add_argument("-T",  "--show-type",  action="store_true", help="network card type")
    nw.add_argument("-d",  "--driver",  action="store_true", help="driver module")
    nw.add_argument("-F",  "--firmware-version",  action="store_true", help="firmware version")
    return parser


def main():

    parser = set_arguments()

    try:
        args = parser.parse_args()
    except OSError:
        parser.print_help()
        sys.exit(1)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    devicetype = args.devicetype

    def get_table_header(args):

        header_options = (
            ('type','Type', 'disk','l'),
            ('model', 'Model', 'disk',"l"),
            ('serial', 'Serial Number', 'disk',"l"),
            ('state', 'State', 'disk',"r"),
            ('apm', 'APM', 'disk',"r"),
            ('size', 'GB', 'disk',"r"),
            ('speed', 'Gbps', 'disk',"l"),
            ('firmware', 'Firmware', 'disk',"l"),
            ('controller', 'Controller', 'disk',"l"),
            ('pcipath', '/dev/disk/by-path', 'disk',"l"),
            ('wwn', '/dev/disk/by-id/wwn*', 'disk',"l"),
            ('scsi', '/dev/disk/by-id/scsi*', 'disk',"l"),
            ('temp', 'Temp', 'disk',"r"),
            ('hours', 'Hours', 'disk',"r"),
            ('pending', 'PS', 'disk',"r"),
            ('reallocated', 'RS', 'disk',"r"),
            ('reallocatedevent', 'RSE', 'disk',"r"),
            ('crc', 'CRC', 'disk',"r"),
            ('startstop', 'Spin', 'disk',"r"),
            ('park', 'Park', 'disk',"r"),
            ('link', 'Link', 'net',"r"),
            ('ipv4', 'IPv4', 'net',"r"),
            ('ipv6', 'IPv6', 'net',"r"),
            ('mac', 'MAC', 'net',"r"),
            ('show_type', 'Type', 'net',"r"),
            ('driver', 'Driver', 'net',"r"),
            ('firmware', 'Firmware', 'net',"r"))

        header = ['Dev']

        for option in header_options:
            if option[2] == args.devicetype:
                if args.all_opts or getattr(args, option[0]):
                        if option[2] == args.devicetype:
                            header.append(option[1])

        #print "Header " + str(header)

        return header

    table_data = []
    table_header = get_table_header(args)

    for device in get_devices(devicetype):
        if not device.startswith("md") and not device.startswith("ram") and not device.startswith("loop"):
            devicedata = process_device(device, args)
            if devicedata:
                table_data.append(devicedata)

    display_table(table_header, table_data, args)


def get_devices(devicetype):

    if devicetype == "disk":
        devices = get_block_devices()

    elif devicetype == "net":
        devices = get_interfaces()

    for device in devices:
        yield device
    return

#
# Get all network devices
#
def get_net_devices():
    netdevices = open('/proc/net/dev',  'r').readlines()
    return netdevices


def get_interfaces():
    interfaces = []
    devices = get_net_devices()
    for line in devices[2:]:
        data = line.split(':')
        interfaces.append(data[0].strip())
        interfaces.sort()
    return interfaces


#
# Get all disk devices
#
def get_block_devices():
    devicepath = "/sys/block"
    diskdevices = os.listdir(devicepath)
    diskdevices.sort()
    return diskdevices


def get_pci_devices():
    try:
        pci_devices = subprocess.Popen(['lspci'],  stdout=subprocess.PIPE,
                                       stderr=
                                       subprocess.PIPE).communicate()[0]
        return pci_devices
    except:
        print("Error when executing lspci,  you might need 'pciutils'\
                 if you run a Red Hat flavour.")
        sys.exit(1)


def get_all_disk_paths():
    disk_by_path_data = subprocess.Popen(['ls',  '-alh',  '/dev/disk/by-path'],
                                         stdout=subprocess.PIPE,
                                         stderr=
                                         subprocess.PIPE).communicate()[0]
    return disk_by_path_data


def get_all_disk_wwns():
    disk_by_id_data = subprocess.Popen(['ls',  '-alh',  '/dev/disk/by-id'],
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE).communicate()[0]
    return disk_by_id_data


def decode_data(data):
    decoded = None
    if isinstance(data, bytes):
        decoded = data.decode('utf-8')
    elif isinstance(data, str):
        decoded = data
    else: 
        print(f"I can't deal with type {type(data)}")
        sys.exit(1)
    return decoded

def generic_match_finder(device, data, pattern, matchgroup, split, itemnumber):
    for item in data.splitlines():
        item = decode_data(item)
        if device in item:
            regex = re.compile(pattern + '(.*)')
            match = regex.search(item)
            if match:
                model = match.group(matchgroup).split(split)[itemnumber]
                return model
    return ""


def get_disk_deviceid(diskdevice, diskbypathdata):
    deviceid = generic_match_finder(diskdevice, diskbypathdata, 'pci-0000:', 1,
                                    ".", 0)
    return deviceid


def get_disk_path(diskdevice, diskbypathdata):
    diskpath = generic_match_finder(diskdevice, diskbypathdata, 'pci-', 0, " ",
                                    0)
    return diskpath


def get_disk_wwn(diskdevice, diskbyiddata):
    diskwwn = generic_match_finder(diskdevice, diskbyiddata, 'wwn', 0, " ", 0)
    return diskwwn


def get_disk_scsi(diskdevice, diskbyiddata):
    diskscsi = generic_match_finder(diskdevice, diskbyiddata, 'scsi', 0, " ",
                                    0)
    return diskscsi


def get_pci_device_name(diskdevice, pci_devices, diskbypathdata):
    deviceid = get_disk_deviceid(diskdevice, diskbypathdata)
    devicename = generic_match_finder(deviceid, pci_devices, deviceid, 1, ":", 1)
    return devicename

def get_disk_model(smartdata):
    model = get_generic_parameter_from_smart(smartdata, "model")
    return model.strip()

def get_disk_type(dev):
    lookup = { "1":"HDD","0":"SDD"}
    device = f"/sys/block/{dev}/queue/rotational"
    with open(device,"r") as f:
        value = f.read()
    model = lookup[value.strip()]
    return model.strip()

def get_disk_serial(smartdata):
    serial = get_generic_parameter_from_smart(smartdata, "serial")
    return serial.strip()

def get_disk_drivestate(hdparmdata):
    drivestate = generic_match_finder("", hdparmdata, 'drive state is:', 1, ", ", 0)
    return drivestate.strip()

def get_disk_apmstate(hdparmdata):
    apmstate = generic_match_finder("", hdparmdata, 'Advanced power management level:', 1, ", ", 0)
    return apmstate.strip()

#def get_fdisk_size(device):
#    command = "fdisk -l /dev/" + device
#    p = subprocess.Popen([command],  stdout=subprocess.PIPE,
#                         stderr=subprocess.PIPE,  shell=True)
#    rawdata = p.communicate()
#    return rawdata[0]


def get_disk_speed(smartdata):
    returndata = get_generic_parameter_from_smart(smartdata, "speed")
    return str(returndata) 

def get_disk_size(smartdata):
    rawdata = get_generic_parameter_from_smart(smartdata, "size")
    returndata = round(float(rawdata) / 1000000000)
    return str(returndata)

def get_disk_firmware(smartdata):
    match = get_generic_parameter_from_smart(smartdata, "firmware")
    return match.strip()

def get_hdparm_data(device):
    command = "hdparm -IC " + device
    p = subprocess.Popen([command],  stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,  shell=True)
    rawdata = p.communicate()
    returncode = p.returncode
    if returncode == 13:
        raise IOError
    if returncode == 127:
        raise OSError
    if returncode > 0:
        pass
    return rawdata


def get_disk_data(device):
    try:
        data = get_hdparm_data(device)
        return data[0]
    except IOError:
        print("Is hdparm installed or are you root / using sudo?")
        sys.exit(1)
#
# Processing of SMART DATA
#

def get_smart_attribute_from_json(json, attribute):
    returndata = "?"
    for item in json["ata_smart_attributes"]["table"]:
        if item["name"] == attribute:
            returndata = str(item["raw"]["value"])
    return returndata

def get_smart_conversion_dict():
    conversion_dict = {
        "temperature"               : ["temperature", "current"],
        "model"                     : ["model_name"],
        "firmware"                   : ["firmware_version"],
        "size"                      : ["user_capacity", "bytes"],
        "speed"                     : ["interface_speed","current","string"],
        "serial"                    : ["serial_number"]
    }
    return conversion_dict

def get_generic_parameter_from_smart(data, parameter):
    table = get_smart_conversion_dict()
    path = table[parameter]
    returndata = data
    for x in path:
        try:
            returndata = returndata[x]
        except KeyError:
            returndata = "?"
            break
    return str(returndata)

def get_smart_data(device):
    try:
        child = subprocess.Popen(['smartctl', '-j',  '-a',  '-d',  'ata',  device],
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
    except OSError:
        print("Executing smartctl gave an error, is smartmontools installed?")
        sys.exit(1)

    rawdata = child.communicate()

    if child.returncode:
        child = subprocess.Popen(['smartctl', '-j',  '-a',  device],
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
        rawdata = child.communicate()
        if child.returncode == 1:
            return ""

    smartdata = rawdata[0]
    try:
        smartdata = json.loads(smartdata)
    except json.JSONDecodeError as e:
        print("Invalid JSON syntax:", e)    
    return smartdata

#
# Network functions
#


def search_data_for_match(regex, data):
    data = data.decode('utf-8')
    match = re.search(regex,  data)
    if match:
        return match.group(1)
    return ''


def get_interface_data(interface):
    raw_data = subprocess.Popen(['ip','a','show', interface],
                                stdout=subprocess.PIPE).communicate()[0]
    return raw_data

def get_driver_data(interface, parameter):

    if parameter:
        command = ["ethtool",  parameter,  interface]
    else:
        command = ["ethtool",  interface]

    try:
        raw_data = subprocess.Popen(command,  stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT).communicate()[0]
    except OSError:
        print("It seems that ethtool is not installed...")
        sys.exit(1)

    return raw_data


def get_interface_type(data):
    match = re.search('encap:(\S+)',  data)
    if match:
        return match.group(1)
    return ''


def is_smart_used(args):

    smart_args = [args.all_opts,  
                  args.temp, 
                  args.hours,
                  args.pending,
                  args.reallocated,
                  args.reallocatedevent,
                  args.crc,
                  args.startstop,
                  args.park,
                  args.speed,
                  args.type           
                  ]

    return any(smart_args)


def process_device(dev, args):
    """
    This function gathers all data from a device and puts this data
    into a list. This list will become a single row in the output table.
    """

    devicedata = []

    devicedata.append(dev)

    if args.devicetype == "disk":

        fullpath = "/dev/" + dev

        diskdata = get_disk_data(fullpath)
        
        pci_devices = get_pci_devices()
        disk_paths = get_all_disk_paths()
        disk_wwns = get_all_disk_wwns()

        if is_smart_used(args):
            disksmart = get_smart_data(fullpath)

        if args.type or args.all_opts:
            disktype = get_disk_type(dev)
            devicedata.append(disktype)

        if args.model or args.all_opts:
            diskmodel = get_disk_model(disksmart)
            devicedata.append(diskmodel)

        if args.serial or args.all_opts:
            diskserial = get_disk_serial(disksmart)
            devicedata.append(diskserial)

        if args.state or args.all_opts:
            drivestate = get_disk_drivestate(diskdata)
            devicedata.append(drivestate)

        if args.apm or args.all_opts:
            apmstate = get_disk_apmstate(diskdata)
            devicedata.append(apmstate)

        if args.size or args.all_opts:
            disksize = get_disk_size(disksmart)
            devicedata.append(disksize)

        if args.speed or args.all_opts:
            linkspeed = get_disk_speed(disksmart)
            devicedata.append(linkspeed)

        if args.firmware or args.all_opts:
            diskfw = get_disk_firmware(disksmart)
            devicedata.append(diskfw)

        if args.controller or args.all_opts:
            pcidevice = get_pci_device_name(dev, pci_devices, disk_paths)
            devicedata.append(pcidevice)

        if args.pcipath or args.all_opts:
            devicepath = get_disk_path(dev, disk_paths)
            devicedata.append(devicepath)

        if args.wwn or args.all_opts:
            devicewwn = get_disk_wwn(dev, disk_wwns)
            devicedata.append(devicewwn)

        if args.scsi or args.all_opts:
            devicescsi = get_disk_scsi(dev, disk_wwns)
            devicedata.append(devicescsi)

        #
        # SMART DATA
        #



        if args.temp or args.all_opts:
            disktemp = get_generic_parameter_from_smart(disksmart,
                                                'temperature')
            devicedata.append(disktemp)

        if args.hours or args.all_opts:
            diskpoweronhours = get_smart_attribute_from_json(disksmart,
                                                        'Power_On_Hours')
            devicedata.append(diskpoweronhours)

        if args.pending or args.all_opts:
            match1 = get_smart_attribute_from_json(disksmart,
                                              'Total_Pending_Sectors')
            match2 = get_smart_attribute_from_json(disksmart,
                                              'Current_Pending_Sector')

            if match1:
                diskcurrentpending = match1
            if match2:
                diskcurrentpending = match2
            if not match1 and not match2:
                diskcurrentpending = "?"

            devicedata.append(diskcurrentpending)

        if args.reallocated or args.all_opts:
            diskreallocatedsector = get_smart_attribute_from_json(disksmart, 'Reallocated_Sector_Ct')
            devicedata.append(diskreallocatedsector)

        if args.reallocatedevent or args.all_opts:
            diskreallocatedevent = get_smart_attribute_from_json(disksmart,"Reallocated_Event_Count")
            devicedata.append(diskreallocatedevent)

        if args.crc or args.all_opts:
            diskudmacrcerror = get_smart_attribute_from_json(disksmart, 'UDMA_CRC_Error_Count')
            devicedata.append(diskudmacrcerror)

        if args.startstop or args.all_opts:
            diskstartstop = get_smart_attribute_from_json(disksmart, 'Start_Stop_Count')
            devicedata.append(diskstartstop)

        if args.park or args.all_opts:
            diskloadcycle = get_smart_attribute_from_json(disksmart, 'Load_Cycle_Count')
            devicedata.append(diskloadcycle)

    #
    # Network data
    #
    elif args.devicetype == "net":

        raw_ifconfig = get_interface_data(dev)
        raw_ethtool = get_driver_data(dev, "-i")
        raw_ethtool_extended = get_driver_data(dev, "")

        if args.link or args.all_opts:
            link = search_data_for_match('Link\ detected:\ (\S+)', raw_ethtool_extended)
            devicedata.append(link)

        if args.ipv4 or args.all_opts:
            ipv4 = search_data_for_match('inet (\S+)', raw_ifconfig)
            devicedata.append(ipv4)

        if args.ipv6 or args.all_opts:
            ipv6 = search_data_for_match('inet6 (\S+)', raw_ifconfig)
            devicedata.append(ipv6)

        if args.mac or args.all_opts:
            mac = search_data_for_match('ether (\S+)', raw_ifconfig)
            devicedata.append(mac)

        if args.show_type or args.all_opts:
            itype = search_data_for_match('link/(\S+)', raw_ifconfig)
            devicedata.append(itype)

        if args.driver or args.all_opts:
            driver = search_data_for_match('driver:\ (\S+)', raw_ethtool)
            devicedata.append(driver)

        if args.firmware_version or args.all_opts:
            firmware = search_data_for_match('firmware-version:\ (\S+)', raw_ethtool)
            devicedata.append(firmware)

    else:
        print("This is a bug, please inform the developer.")
        sys.exit(1)

    #print "Devicedata " + str(devicedata)

    return devicedata

#
# Get collumn size for proper table formatting
# Find the biggest string in a collumn
#


def get_collumn_size(table_header, table_data):

    col_count = len(table_data[0])
    col_widths = []

    for i in range(col_count):
        collumn = []
        for row in table_data:

            header_length = len(table_header[i])
            data_length = len(row[i])

            #
            # The width of the header can be bigger than the data
            #

            if header_length > data_length:
                collumn.append(header_length)
            else:
                collumn.append(data_length)

        length = max(collumn)
        col_widths.append(length)

    # print("All coll widths: " + str(col_widths))

    return col_widths


def display_table(table_header, table_data, args):

    header_length = len(table_header)
    data_length = len(table_data[0])

    assert header_length == data_length, "Column count mismatch! %r/%r" % (header_length, data_length)

    col_widths = get_collumn_size(table_header, table_data)

    # Dirty hack to get a closing pipe character at the end of the row
    col_widths.append(1)

    # Some values to calculate the actual table with,  including spacing
    spacing = 1
    delimiter = 3
    table_width = (sum(col_widths) + len(col_widths) * spacing * delimiter) - delimiter

    format = ""
    for col in col_widths:
        if args.transparent:
            form = "  %-" + str(col) + "s "
        else:
            form = "| %-" + str(col) + "s "
            format += form

    #
    # Print header
    #
    table_header.append("")
    if args.transparent:
        if not args.noheader:
            print('%s' % ' '*table_width)
            print(format % tuple(table_header))
            print('%s' % ' '*table_width)
    else:
        print('%s' % '-'*table_width)
        #print table_header
        print(format % tuple(table_header))
        print('%s' % '-'*table_width)

    #
    # Print actual table contents
    #
    for row in table_data:
        row.append("")
        print(format % tuple(row))

    if not args.transparent:
        print('%s' % '-'*table_width)

if __name__ == "__main__":
    main()

